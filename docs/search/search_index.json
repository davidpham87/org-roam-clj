{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Installation \u00b6 The next packages are required to make it work. Emacs Clojure orgmk org-roam mkdocs material and this plugin awesomepages See the pages for the steps of installing each dependencies. Restriction in authoring \u00b6 Because of the export and how mkdocs read markdown files, the first level should be the title of your cards, and then only keep second level headlines. A typical file will look as the following #+TITLE: A good title #+OPTIONS: toc:nil #+ROAM_ALIAS: title the-title good-title #+TAGS: title how-to-write-titles * A good title - tags :: use-org-roam-insert ** First heading Quick start \u00b6 Make sure you fulfill the requirements. Then git clone https ~/Documents/org_roam_clj_files/ cd ~/Documents/org_roam_clj_files/example Set the org-roam-directory in your settings (e.g. init.el ) ( set org-roam-directory \"~/Documents/org_roam_clj_files/example\" ) Go into the example folder, edit some org files, run the org-roam-db-build-cache function. Then clojure -m org-roam-clj.core -t create-tags clojure -m org-roam-clj.core -t markdown Configuration \u00b6 The mkdocs.yml file sets the configuration of mkdocs. See mkdocs material for more details. Emacs settings \u00b6 Make sure to set the org-roam folder to the folder where your deps.edn is located. ( set org-roam-directory \"path/to/root-org-files\" ) You can overwrite the default template with the following to add directly the tags and removal of table of content ( require 's ) ( require 'org-roam ) ( setq org-roam-capture-templates ( let (( s ( s-join \"\\n\" ' ( \"#+TITLE: ${title}\\n#+OPTIONS: toc:nil\" \"#+ROAM_ALIAS: %(s-dashed-words \\\"${title}\\\")\" \"#+TAGS: %(s-dashed-words \\\"${title}\\\")\" \"#+DATE: %<%Y-%m-%d>\" \"\" \"* ${title}\" )))) ( list ( list \"d\" \"default\" 'plain ' ( function org-roam-capture--get-point ) \"%?\" :file-name \"cards/%<%Y%m%d%H%M%S>-${slug}\" :head s :unnarrowed t )))) Generate docs \u00b6 clojure -m org-roam-clj.core -t markdown Docs will be generated in the docs-md folder because github pages only supports distribution from the docs folder (which is a symlink from site) . FAQ \u00b6 Why Clojure and not elisp? \u00b6 Babashka and Clojure were fast enough to perform the task I wanted to do, and my skills in elisp were not good enough to make the project. Possible Extension \u00b6 We do not really need emacs nor org-roam to make the link work. We just need to be able to parse the org files and manage the org-roam.db files. This would open the tool for everyone who do not use Emacs to manage their org files. Nor does it fully depends on org files (we could easily extend it to markdown, with yaml headers).","title":"Installation"},{"location":"#installation","text":"The next packages are required to make it work. Emacs Clojure orgmk org-roam mkdocs material and this plugin awesomepages See the pages for the steps of installing each dependencies.","title":"Installation"},{"location":"#restriction-in-authoring","text":"Because of the export and how mkdocs read markdown files, the first level should be the title of your cards, and then only keep second level headlines. A typical file will look as the following #+TITLE: A good title #+OPTIONS: toc:nil #+ROAM_ALIAS: title the-title good-title #+TAGS: title how-to-write-titles * A good title - tags :: use-org-roam-insert ** First heading","title":"Restriction in authoring"},{"location":"#quick-start","text":"Make sure you fulfill the requirements. Then git clone https ~/Documents/org_roam_clj_files/ cd ~/Documents/org_roam_clj_files/example Set the org-roam-directory in your settings (e.g. init.el ) ( set org-roam-directory \"~/Documents/org_roam_clj_files/example\" ) Go into the example folder, edit some org files, run the org-roam-db-build-cache function. Then clojure -m org-roam-clj.core -t create-tags clojure -m org-roam-clj.core -t markdown","title":"Quick start"},{"location":"#configuration","text":"The mkdocs.yml file sets the configuration of mkdocs. See mkdocs material for more details.","title":"Configuration"},{"location":"#emacs-settings","text":"Make sure to set the org-roam folder to the folder where your deps.edn is located. ( set org-roam-directory \"path/to/root-org-files\" ) You can overwrite the default template with the following to add directly the tags and removal of table of content ( require 's ) ( require 'org-roam ) ( setq org-roam-capture-templates ( let (( s ( s-join \"\\n\" ' ( \"#+TITLE: ${title}\\n#+OPTIONS: toc:nil\" \"#+ROAM_ALIAS: %(s-dashed-words \\\"${title}\\\")\" \"#+TAGS: %(s-dashed-words \\\"${title}\\\")\" \"#+DATE: %<%Y-%m-%d>\" \"\" \"* ${title}\" )))) ( list ( list \"d\" \"default\" 'plain ' ( function org-roam-capture--get-point ) \"%?\" :file-name \"cards/%<%Y%m%d%H%M%S>-${slug}\" :head s :unnarrowed t ))))","title":"Emacs settings"},{"location":"#generate-docs","text":"clojure -m org-roam-clj.core -t markdown Docs will be generated in the docs-md folder because github pages only supports distribution from the docs folder (which is a symlink from site) .","title":"Generate docs"},{"location":"#faq","text":"","title":"FAQ"},{"location":"#why-clojure-and-not-elisp","text":"Babashka and Clojure were fast enough to perform the task I wanted to do, and my skills in elisp were not good enough to make the project.","title":"Why Clojure and not elisp?"},{"location":"#possible-extension","text":"We do not really need emacs nor org-roam to make the link work. We just need to be able to parse the org files and manage the org-roam.db files. This would open the tool for everyone who do not use Emacs to manage their org files. Nor does it fully depends on org files (we could easily extend it to markdown, with yaml headers).","title":"Possible Extension"},{"location":"org-roam-clj/async/","text":"org-roam-clj.async \u00b6 Some functionalities for handling with core.async. ( ns ) ( ns org-roam-clj.async ( :require [ org-roam-clj.utils :refer ( now-formatted )] [ clojure.core.async :as a :refer ( <! >! go-loop chan )])) log-tasks \u00b6 Logs to console the events. ( log-tasks ) ( log-tasks c ) ( defn ) ( defn log-tasks ([] ( log-tasks ( chan 42 ))) ([ c ] ( a/thread ( loop [] ( when-let [ s ( a/<!! c )] ( println ( now-formatted ) s ) ( recur ))) ( println \"Closed log chan\" )) c )) finished-tasks \u00b6 Channel to collect the finished task. ( finished-tasks c ) ( defn ) ( defn finished-tasks [ c ] ( let [ result ( atom [])] ( a/thread ( loop [] ( when-let [ x ( a/<!! c )] ( when ( = ( first x ) :end ) ( swap! result conj x )) ( recur ))) ( println \"Finished tasks\" )) result )) master-coordinator \u00b6 ( master-coordinator c log-chan pool ) ( defn ) ( defn master-coordinator [ c log-chan pool ] ( let [ alts-pool-vec ( fn [ pool value ] ( mapv # ( vector %1 %2 ) pool ( repeat value )))] ( go-loop [] ( when-let [ x ( <! c )] ( >! log-chan [ :received x ]) ( a/alts! ( alts-pool-vec pool x )) ( recur )))) c ) emit-end \u00b6 ( emit-end f c ) ( defn ) ( defn emit-end [ f c ] ( fn [ & args ] ( apply f args ) ( a/offer! c ( vec args )))) worker-chan \u00b6 Create a worker channel for handling async working. TODO: maybe add the options to create thread instead of go-loop. ( worker-chan f log-chan ) ( defn ) ( defn worker-chan [ f log-chan ] ( let [ c ( chan )] ( go-loop [] ( when-let [[ k & args ] ( <! c )] ( >! log-chan [ :start k args ]) ( apply f k args ) ( >! log-chan [ :end k args ]) ( recur ))) c ))","title":"org-roam-clj.async"},{"location":"org-roam-clj/async/#org-roam-cljasync","text":"Some functionalities for handling with core.async. ( ns ) ( ns org-roam-clj.async ( :require [ org-roam-clj.utils :refer ( now-formatted )] [ clojure.core.async :as a :refer ( <! >! go-loop chan )]))","title":"org-roam-clj.async"},{"location":"org-roam-clj/async/#log-tasks","text":"Logs to console the events. ( log-tasks ) ( log-tasks c ) ( defn ) ( defn log-tasks ([] ( log-tasks ( chan 42 ))) ([ c ] ( a/thread ( loop [] ( when-let [ s ( a/<!! c )] ( println ( now-formatted ) s ) ( recur ))) ( println \"Closed log chan\" )) c ))","title":"log-tasks"},{"location":"org-roam-clj/async/#finished-tasks","text":"Channel to collect the finished task. ( finished-tasks c ) ( defn ) ( defn finished-tasks [ c ] ( let [ result ( atom [])] ( a/thread ( loop [] ( when-let [ x ( a/<!! c )] ( when ( = ( first x ) :end ) ( swap! result conj x )) ( recur ))) ( println \"Finished tasks\" )) result ))","title":"finished-tasks"},{"location":"org-roam-clj/async/#master-coordinator","text":"( master-coordinator c log-chan pool ) ( defn ) ( defn master-coordinator [ c log-chan pool ] ( let [ alts-pool-vec ( fn [ pool value ] ( mapv # ( vector %1 %2 ) pool ( repeat value )))] ( go-loop [] ( when-let [ x ( <! c )] ( >! log-chan [ :received x ]) ( a/alts! ( alts-pool-vec pool x )) ( recur )))) c )","title":"master-coordinator"},{"location":"org-roam-clj/async/#emit-end","text":"( emit-end f c ) ( defn ) ( defn emit-end [ f c ] ( fn [ & args ] ( apply f args ) ( a/offer! c ( vec args ))))","title":"emit-end"},{"location":"org-roam-clj/async/#worker-chan","text":"Create a worker channel for handling async working. TODO: maybe add the options to create thread instead of go-loop. ( worker-chan f log-chan ) ( defn ) ( defn worker-chan [ f log-chan ] ( let [ c ( chan )] ( go-loop [] ( when-let [[ k & args ] ( <! c )] ( >! log-chan [ :start k args ]) ( apply f k args ) ( >! log-chan [ :end k args ]) ( recur ))) c ))","title":"worker-chan"},{"location":"org-roam-clj/core/","text":"org-roam-clj.core \u00b6 ( ns ) ( ns org-roam-clj.core ( :require [ clojure.tools.cli :refer ( parse-opts )] [ org-roam-clj.markdown ] [ org-roam-clj.tags ])) cli-options \u00b6 ( def ) ( def cli-options [[ \"-t\" \"--task TASK\" \"Which task to perform. One of clear-tags, create-tags, markdown, clean-markdown\" :default :markdown :parse-fn keyword :validate [ # { :clear-tags :create-tags :markdown :clean-markdown }]] [ \"-h\" \"--help\" ]]) -main \u00b6 ( -main & args ) ( defn ) ( defn -main [ & args ] ( let [ cli-args ( parse-opts args cli-options )] ( if ( get-in cli-args [ :options :help ]) ( println ( :summary cli-args )) ( case ( get-in cli-args [ :options :task ]) :create-tags ( org-roam-clj.tags/create-tags ) :clear-tags ( org-roam-clj.tags/clear-tags ) :markdown ( org-roam-clj.markdown/convert-org-files ) :clean-markdown ( org-roam-clj.markdown/clean-folder \"docs-md\" )))))","title":"org-roam-clj.core"},{"location":"org-roam-clj/core/#org-roam-cljcore","text":"( ns ) ( ns org-roam-clj.core ( :require [ clojure.tools.cli :refer ( parse-opts )] [ org-roam-clj.markdown ] [ org-roam-clj.tags ]))","title":"org-roam-clj.core"},{"location":"org-roam-clj/core/#cli-options","text":"( def ) ( def cli-options [[ \"-t\" \"--task TASK\" \"Which task to perform. One of clear-tags, create-tags, markdown, clean-markdown\" :default :markdown :parse-fn keyword :validate [ # { :clear-tags :create-tags :markdown :clean-markdown }]] [ \"-h\" \"--help\" ]])","title":"cli-options"},{"location":"org-roam-clj/core/#-main","text":"( -main & args ) ( defn ) ( defn -main [ & args ] ( let [ cli-args ( parse-opts args cli-options )] ( if ( get-in cli-args [ :options :help ]) ( println ( :summary cli-args )) ( case ( get-in cli-args [ :options :task ]) :create-tags ( org-roam-clj.tags/create-tags ) :clear-tags ( org-roam-clj.tags/clear-tags ) :markdown ( org-roam-clj.markdown/convert-org-files ) :clean-markdown ( org-roam-clj.markdown/clean-folder \"docs-md\" )))))","title":"-main"},{"location":"org-roam-clj/db/","text":"org-roam-clj.db \u00b6 Data converters for org-roam-db ( ns ) ( ns org-roam-clj.db ( :require [ clojure.edn ] [ clojure.java.io :as io ] [ clojure.string :as str ] [ honeysql.core :as sql ] [ org-roam-clj.utils :refer ( sha1-str gather-org-files )] [ next.jdbc :as jdbc ] [ next.jdbc.result-set :as rs ])) db \u00b6 ( def ) ( def db { :dbtype \"sqlite\" :dbname \"org-roam.db\" }) data-resource \u00b6 ( data-resource ) ( data-resource db ) ( defn ) ( defn data-resource ([] ( data-resource db )) ([ db ] ( jdbc/get-datasource db ))) connection \u00b6 ( def ) ( def connection ( atom ( jdbc/get-connection ( data-resource )))) home-directory \u00b6 ( def ) ( def home-directory ( memoize ( fn [] ( System/getProperty \"user.home\" )))) execute-query! \u00b6 ( execute-query! query ) ( execute-query! query connection ) ( defn ) ( defn execute-query! ([ query ] ( execute-query! query @ connection )) ([ query connection ] ( jdbc/execute! connection query { :builder-fn rs/as-unqualified-maps }))) expand-home \u00b6 Inspired by this answer https://stackoverflow.com/questions/29585928/how-to-substitute-path-to-home-for. ( expand-home s ) ( defn ) ( defn expand-home [ s ] ( if ( .startsWith s \"~\" ) ( clojure.string/replace-first s \"~\" ( home-directory )) s )) canonical-path \u00b6 ( canonical-path s ) ( defn ) ( defn canonical-path [ s ] ( .getCanonicalPath ( io/file s ))) parse-lisp-record \u00b6 Parsing error The displayed code is not valid. This is due to Marginalia's parsing code. ( defn ) ( defn parse-lisp-record [ m ] ( reduce-kv ( fn [ m k v ] ( assoc m k ( try ( clojure.edn/read-string v ) ( catch Exception _ ( println v ) ( str ( take-while # ( not= \" \\) ( drop 2 v ))))))) {} m )) titles \u00b6 Parsing error The displayed code is not valid. This is due to Marginalia's parsing code. ( defn ) ( defn titles [] ( let [ xs ( execute-query! [ \"select * from titles\" ])] ( into [] ( comp ( filter # ( str/ends-with? ( :file % ) \" .org \\ )) ( map parse-lisp-record ) ( map # ( update % :file expand-home ))) xs ))) backlinks \u00b6 ( backlinks ) ( defn ) ( defn backlinks [] ( ->> ( execute-query! [ \"select \\\"to\\\", \\\"from\\\" from links\" ]) ( map parse-lisp-record ) ( map # ( reduce ( fn [ m k ] ( update m k expand-home )) % [ :to :from ])) ( group-by :to ))) tags \u00b6 ( tags ) ( defn ) ( defn tags [] ( ->> ( execute-query! [ \"select file, tags from tags\" ]) ( map parse-lisp-record ) ( map # ( update % :file expand-home )) ( reduce ( fn [ m { :keys [ file tags ]}] ( assoc m file tags )) {}))) create-files-clj \u00b6 ( create-files-clj ) ( defn ) ( defn create-files-clj [] ( try ( execute-query! [ \"create table files_clj ( file varchar(3000) PRIMARY KEY, hash vacharc(40))\" ]) ( catch org.sqlite.SQLiteException _ ( println \"Table files_clj already exists.\" )))) insert-file-hash-query \u00b6 ( insert-file-hash-query filename content ) ( defn ) ( defn insert-file-hash-query [ filename content ] ( let [ sha1 ( sha1-str content )] { :insert-into :files_clj :columns [ :file :hash ] :values [[ filename sha1 ]]})) update-file-hash-query \u00b6 ( update-file-hash-query filename content ) ( defn ) ( defn update-file-hash-query [ filename content ] ( let [ sha1 ( sha1-str content )] { :update :files_clj :set { :file filename :hash sha1 } :where [ := :file filename ]})) file-query \u00b6 ( file-query filename ) ( defn ) ( defn file-query [ filename ] { :select [ :* ] :from [ :files_clj ] :where [ := :file filename ] :limit 1 }) files-query \u00b6 All files and their hashes. ( files-query ) ( defn ) ( defn files-query [] { :select [ :* ] :from [ :files_clj ]}) file-exists? \u00b6 ( file-exists? filename ) ( defn ) ( defn file-exists? [ filename ] ( pos? ( count ( execute-query! ( sql/format ( file-query filename )))))) store-file-hash-query \u00b6 ( store-file-hash-query filename content ) ( store-file-hash-query filename content update? ) ( defn ) ( defn store-file-hash-query ([ filename content ] ( store-file-hash-query filename content ( file-exists? filename ))) ([ filename content update? ] ( if update? ( update-file-hash-query filename content ) ( insert-file-hash-query filename content )))) store-file-hash! \u00b6 ( store-file-hash! filename content ) ( store-file-hash! filename content update? ) ( defn ) ( defn store-file-hash! ([ filename content ] ( store-file-hash! filename content ( file-exists? filename ))) ([ filename content update? ] ( -> ( store-file-hash-query filename content update? ) sql/format execute-query! ))) store-hash-content! \u00b6 ( store-hash-content! f ) ( defn ) ( defn store-hash-content! [ f ] ( let [ filename ( .getCanonicalPath f )] ( store-file-hash! filename ( slurp filename )))) build-files-hash \u00b6 ( build-files-hash root ) ( defn ) ( defn build-files-hash [ root ] ( doseq [ f ( gather-org-files root )] ( store-hash-content! f ))) files-hashes \u00b6 ( files-hashes ) ( defn ) ( defn files-hashes [] ( -> ( files-query ) sql/format execute-query! )) Rich Comment \u00b6 # _ ( defn updated-files [ files ] { :select [ :* ] :from [ :files_clj ] :where [ :in :file files ]}) ( comment ( def ds ( data-resource )) ( def ts ( titles )) ( ->> titles ( map clojure.edn/read-string ) # _ ( filter # ( str/endswith ( :file % ) \".org\" ))) ( group-by :to ( map parse-lisp-record ( execute-query! [ \"select \\\"to\\\", \\\"from\\\" from links\" ]))) ( create-files-clj ) ( clojure.pprint/pprint ( titles )) ( clojure.pprint/pprint ( backlinks )) ( titles ) ( build-files-hash \".\" ) ( def sql-map { :select [ :* ] :from [ :files ]}) ( execute-query! ( sql/format sql-map )) ( execute-query! ( sql/format sql-map )) ;; just for fun use datascript and store the atom into a single transit json ( execute-query! ( sql/format ( store-file-hash-query \"whatever.clj\" \"a\u00e9sldkfj\u00e9lkj\u00e9aldskjf\u00e9lkj\" ))) ( execute-query! ( sql/format ( update-file-hash-query \"hello.clj\" \"a\u00e9sldkfj\u00e9lkj\u00e9aldskjf\u00e9lkj\" ))) ( execute-query! ( sql/format { :select [ :* ] :from [ :files_clj ] :limit 10 })))","title":"org-roam-clj.db"},{"location":"org-roam-clj/db/#org-roam-cljdb","text":"Data converters for org-roam-db ( ns ) ( ns org-roam-clj.db ( :require [ clojure.edn ] [ clojure.java.io :as io ] [ clojure.string :as str ] [ honeysql.core :as sql ] [ org-roam-clj.utils :refer ( sha1-str gather-org-files )] [ next.jdbc :as jdbc ] [ next.jdbc.result-set :as rs ]))","title":"org-roam-clj.db"},{"location":"org-roam-clj/db/#db","text":"( def ) ( def db { :dbtype \"sqlite\" :dbname \"org-roam.db\" })","title":"db"},{"location":"org-roam-clj/db/#data-resource","text":"( data-resource ) ( data-resource db ) ( defn ) ( defn data-resource ([] ( data-resource db )) ([ db ] ( jdbc/get-datasource db )))","title":"data-resource"},{"location":"org-roam-clj/db/#connection","text":"( def ) ( def connection ( atom ( jdbc/get-connection ( data-resource ))))","title":"connection"},{"location":"org-roam-clj/db/#home-directory","text":"( def ) ( def home-directory ( memoize ( fn [] ( System/getProperty \"user.home\" ))))","title":"home-directory"},{"location":"org-roam-clj/db/#execute-query","text":"( execute-query! query ) ( execute-query! query connection ) ( defn ) ( defn execute-query! ([ query ] ( execute-query! query @ connection )) ([ query connection ] ( jdbc/execute! connection query { :builder-fn rs/as-unqualified-maps })))","title":"execute-query!"},{"location":"org-roam-clj/db/#expand-home","text":"Inspired by this answer https://stackoverflow.com/questions/29585928/how-to-substitute-path-to-home-for. ( expand-home s ) ( defn ) ( defn expand-home [ s ] ( if ( .startsWith s \"~\" ) ( clojure.string/replace-first s \"~\" ( home-directory )) s ))","title":"expand-home"},{"location":"org-roam-clj/db/#canonical-path","text":"( canonical-path s ) ( defn ) ( defn canonical-path [ s ] ( .getCanonicalPath ( io/file s )))","title":"canonical-path"},{"location":"org-roam-clj/db/#parse-lisp-record","text":"Parsing error The displayed code is not valid. This is due to Marginalia's parsing code. ( defn ) ( defn parse-lisp-record [ m ] ( reduce-kv ( fn [ m k v ] ( assoc m k ( try ( clojure.edn/read-string v ) ( catch Exception _ ( println v ) ( str ( take-while # ( not= \" \\) ( drop 2 v ))))))) {} m ))","title":"parse-lisp-record"},{"location":"org-roam-clj/db/#titles","text":"Parsing error The displayed code is not valid. This is due to Marginalia's parsing code. ( defn ) ( defn titles [] ( let [ xs ( execute-query! [ \"select * from titles\" ])] ( into [] ( comp ( filter # ( str/ends-with? ( :file % ) \" .org \\ )) ( map parse-lisp-record ) ( map # ( update % :file expand-home ))) xs )))","title":"titles"},{"location":"org-roam-clj/db/#backlinks","text":"( backlinks ) ( defn ) ( defn backlinks [] ( ->> ( execute-query! [ \"select \\\"to\\\", \\\"from\\\" from links\" ]) ( map parse-lisp-record ) ( map # ( reduce ( fn [ m k ] ( update m k expand-home )) % [ :to :from ])) ( group-by :to )))","title":"backlinks"},{"location":"org-roam-clj/db/#tags","text":"( tags ) ( defn ) ( defn tags [] ( ->> ( execute-query! [ \"select file, tags from tags\" ]) ( map parse-lisp-record ) ( map # ( update % :file expand-home )) ( reduce ( fn [ m { :keys [ file tags ]}] ( assoc m file tags )) {})))","title":"tags"},{"location":"org-roam-clj/db/#create-files-clj","text":"( create-files-clj ) ( defn ) ( defn create-files-clj [] ( try ( execute-query! [ \"create table files_clj ( file varchar(3000) PRIMARY KEY, hash vacharc(40))\" ]) ( catch org.sqlite.SQLiteException _ ( println \"Table files_clj already exists.\" ))))","title":"create-files-clj"},{"location":"org-roam-clj/db/#insert-file-hash-query","text":"( insert-file-hash-query filename content ) ( defn ) ( defn insert-file-hash-query [ filename content ] ( let [ sha1 ( sha1-str content )] { :insert-into :files_clj :columns [ :file :hash ] :values [[ filename sha1 ]]}))","title":"insert-file-hash-query"},{"location":"org-roam-clj/db/#update-file-hash-query","text":"( update-file-hash-query filename content ) ( defn ) ( defn update-file-hash-query [ filename content ] ( let [ sha1 ( sha1-str content )] { :update :files_clj :set { :file filename :hash sha1 } :where [ := :file filename ]}))","title":"update-file-hash-query"},{"location":"org-roam-clj/db/#file-query","text":"( file-query filename ) ( defn ) ( defn file-query [ filename ] { :select [ :* ] :from [ :files_clj ] :where [ := :file filename ] :limit 1 })","title":"file-query"},{"location":"org-roam-clj/db/#files-query","text":"All files and their hashes. ( files-query ) ( defn ) ( defn files-query [] { :select [ :* ] :from [ :files_clj ]})","title":"files-query"},{"location":"org-roam-clj/db/#file-exists","text":"( file-exists? filename ) ( defn ) ( defn file-exists? [ filename ] ( pos? ( count ( execute-query! ( sql/format ( file-query filename ))))))","title":"file-exists?"},{"location":"org-roam-clj/db/#store-file-hash-query","text":"( store-file-hash-query filename content ) ( store-file-hash-query filename content update? ) ( defn ) ( defn store-file-hash-query ([ filename content ] ( store-file-hash-query filename content ( file-exists? filename ))) ([ filename content update? ] ( if update? ( update-file-hash-query filename content ) ( insert-file-hash-query filename content ))))","title":"store-file-hash-query"},{"location":"org-roam-clj/db/#store-file-hash","text":"( store-file-hash! filename content ) ( store-file-hash! filename content update? ) ( defn ) ( defn store-file-hash! ([ filename content ] ( store-file-hash! filename content ( file-exists? filename ))) ([ filename content update? ] ( -> ( store-file-hash-query filename content update? ) sql/format execute-query! )))","title":"store-file-hash!"},{"location":"org-roam-clj/db/#store-hash-content","text":"( store-hash-content! f ) ( defn ) ( defn store-hash-content! [ f ] ( let [ filename ( .getCanonicalPath f )] ( store-file-hash! filename ( slurp filename ))))","title":"store-hash-content!"},{"location":"org-roam-clj/db/#build-files-hash","text":"( build-files-hash root ) ( defn ) ( defn build-files-hash [ root ] ( doseq [ f ( gather-org-files root )] ( store-hash-content! f )))","title":"build-files-hash"},{"location":"org-roam-clj/db/#files-hashes","text":"( files-hashes ) ( defn ) ( defn files-hashes [] ( -> ( files-query ) sql/format execute-query! ))","title":"files-hashes"},{"location":"org-roam-clj/db/#rich-comment","text":"# _ ( defn updated-files [ files ] { :select [ :* ] :from [ :files_clj ] :where [ :in :file files ]}) ( comment ( def ds ( data-resource )) ( def ts ( titles )) ( ->> titles ( map clojure.edn/read-string ) # _ ( filter # ( str/endswith ( :file % ) \".org\" ))) ( group-by :to ( map parse-lisp-record ( execute-query! [ \"select \\\"to\\\", \\\"from\\\" from links\" ]))) ( create-files-clj ) ( clojure.pprint/pprint ( titles )) ( clojure.pprint/pprint ( backlinks )) ( titles ) ( build-files-hash \".\" ) ( def sql-map { :select [ :* ] :from [ :files ]}) ( execute-query! ( sql/format sql-map )) ( execute-query! ( sql/format sql-map )) ;; just for fun use datascript and store the atom into a single transit json ( execute-query! ( sql/format ( store-file-hash-query \"whatever.clj\" \"a\u00e9sldkfj\u00e9lkj\u00e9aldskjf\u00e9lkj\" ))) ( execute-query! ( sql/format ( update-file-hash-query \"hello.clj\" \"a\u00e9sldkfj\u00e9lkj\u00e9aldskjf\u00e9lkj\" ))) ( execute-query! ( sql/format { :select [ :* ] :from [ :files_clj ] :limit 10 })))","title":"Rich Comment"},{"location":"org-roam-clj/markdown/","text":"org-roam-clj.markdown \u00b6 ( ns ) ( ns org-roam-clj.markdown ( :require [ clojure.core.async :as a :refer ( chan )] [ clojure.java.io :as io ] [ clojure.java.shell :as sh ] [ clojure.string :as str ] [ org-roam-clj.db ] [ org-roam-clj.async :refer ( master-coordinator log-tasks worker-chan finished-tasks )] [ org-roam-clj.utils :refer ( sha1-str now-formatted replace-extension )])) pandoc-cli-args \u00b6 ( pandoc-cli-args m ) ( defn ) ( defn pandoc-cli-args [ m ] ( let [ key->str ( fn [ k ] ( if ( keyword k ) ( let [ s ( name k ) dash ( case ( count s ) 1 \"-\" \"--\" )] ( str dash s )) k )) value->str # ( if ( keyword % ) ( name % ) % )] ( reduce # ( conj %1 ( key->str ( first %2 )) ( value->str ( second %2 ))) [] m ))) pandoc \u00b6 ( pandoc file & [{ :as opts }]) ( defn ) ( defn pandoc [ file & [{ :as opts }]] ( let [ args ( into [ \"pandoc\" file ] ( pandoc-cli-args opts )) p ( ProcessBuilder. args )] ( .start p ))) orgmk \u00b6 ( orgmk file ) ( defn ) ( defn orgmk [ file ] ( -> ( ProcessBuilder. [ \"org2gfm\" file ]) ( .start ))) work \u00b6 ( defmulti ) ( defmulti work ( fn [ k & _ ] k )) ( defmethod work :default [ _ ] identity ) ( defmethod work :pandoc [ _ file ] ( let [ filename ( .getPath file ) md-filename ( -> ( replace-extension filename \"md\" ) ( str/replace # \"^\\./\" \"\" )) p ( pandoc filename { :t :gfm :o ( ->> ( str \"docs-md/\" md-filename ))}) status ( .waitFor p )] ( println ( now-formatted ) \"Exit status for pandoc (\" filename \"): \" status ))) work :orgmk \u00b6 ( work _ file ) ( defmethod ) ( defmethod work :orgmk [ _ file ] ( let [ filename ( .getPath file ) md-filename ( -> ( replace-extension filename \"md\" ) ( str/replace # \"^\\./\" \"\" )) dst ( io/file ( str \"docs-md/\" md-filename )) p ( orgmk filename ) status ( .waitFor p )] ( println ( now-formatted ) \"Exit status for orgmk (\" filename \"): \" status ) ( when ( zero? status ) ( when-not ( .exists dst ) ( io/make-parents dst )) ( io/copy ( io/file md-filename ) dst ) ( io/delete-file md-filename )))) work :mkdocs \u00b6 ( work _ c ) ( defmethod ) ( defmethod work :mkdocs [ _ c ] ( a/put! c ( sh/sh \"mkdocs\" \"build\" ))) worker-pool \u00b6 ( worker-pool n log-chan ) ( defn ) ( defn worker-pool [ n log-chan ] ( mapv ( fn [ _ ] ( worker-chan work log-chan )) ( range n ))) modified-files \u00b6 ( modified-files fs ) ( defn ) ( defn modified-files [ fs ] ( let [ files-hashes ( ->> ( org-roam-clj.db/files-hashes ) ( reduce # ( assoc %1 ( :file %2 ) ( :hash %2 )) {}))] ( filter # ( not= ( get files-hashes ( str ( .getCanonicalPath % ))) ( sha1-str ( slurp ( str % )))) fs ))) convert-org-files \u00b6 ( convert-org-files ) ( convert-org-files root ) ( defn ) ( defn convert-org-files ([] ( convert-org-files \".\" )) ([ root ] ( let [ fs ( ->> ( file-seq ( io/file root )) ( filter # ( str/ends-with? % \".org\" )) modified-files ) size 16 master-chan ( chan size ) log-chan ( chan size ) log-mult ( a/mult log-chan ) println-chan ( chan size ) task-chan ( chan size ) terminated-tasks ( finished-tasks task-chan ) elapsed-time ( atom 0 )] ( a/tap log-mult println-chan ) ( a/tap log-mult task-chan ) ( log-tasks println-chan ) ( master-coordinator master-chan log-chan ( worker-pool size log-chan )) ( doseq [ org-file fs ] ( a/>!! master-chan [ :orgmk org-file ])) ( while ( and ( not= ( count @ terminated-tasks ) ( count fs )) ( not= @ elapsed-time 3600 )) ( when-not ( mod @ elapsed-time 5 ) ( a/offer! println-chan [ :log \"Waiting for conversion to finish\" ]) ( a/offer! println-chan [ :log \"Ratio: \" ( count @ terminated-tasks ) \"/\" ( count fs )])) ( a/<!! ( a/timeout 1000 )) ( swap! elapsed-time inc )) ( println ( count @ terminated-tasks ) ( count fs )) ( let [ final-chan ( chan )] ( a/>!! master-chan [ :mkdocs final-chan ]) ( println ( a/<!! final-chan ))) ( println \"Store files hashes for efficiency\" ) ( org-roam-clj.db/create-files-clj ) ( doseq [ f fs ] ( org-roam-clj.db/store-hash-content! f ))))) clean-folder \u00b6 ( clean-folder src ) ( defn ) ( defn clean-folder [ src ] ( let [ fs ( filter # ( str/ends-with? % \".md\" ) ( file-seq ( io/file src )))] ( doseq [ f fs ] ( io/delete-file f )))) -main \u00b6 ( -main ) ( defn ) ( defn -main [] ( println \"Starting to convert org-files\" ) ( convert-org-files ) ( println \"End of script\" )) Rich Comment \u00b6 ( comment ( tap> ( org-roam-clj.db/files-hashes )) )","title":"org-roam-clj.markdown"},{"location":"org-roam-clj/markdown/#org-roam-cljmarkdown","text":"( ns ) ( ns org-roam-clj.markdown ( :require [ clojure.core.async :as a :refer ( chan )] [ clojure.java.io :as io ] [ clojure.java.shell :as sh ] [ clojure.string :as str ] [ org-roam-clj.db ] [ org-roam-clj.async :refer ( master-coordinator log-tasks worker-chan finished-tasks )] [ org-roam-clj.utils :refer ( sha1-str now-formatted replace-extension )]))","title":"org-roam-clj.markdown"},{"location":"org-roam-clj/markdown/#pandoc-cli-args","text":"( pandoc-cli-args m ) ( defn ) ( defn pandoc-cli-args [ m ] ( let [ key->str ( fn [ k ] ( if ( keyword k ) ( let [ s ( name k ) dash ( case ( count s ) 1 \"-\" \"--\" )] ( str dash s )) k )) value->str # ( if ( keyword % ) ( name % ) % )] ( reduce # ( conj %1 ( key->str ( first %2 )) ( value->str ( second %2 ))) [] m )))","title":"pandoc-cli-args"},{"location":"org-roam-clj/markdown/#pandoc","text":"( pandoc file & [{ :as opts }]) ( defn ) ( defn pandoc [ file & [{ :as opts }]] ( let [ args ( into [ \"pandoc\" file ] ( pandoc-cli-args opts )) p ( ProcessBuilder. args )] ( .start p )))","title":"pandoc"},{"location":"org-roam-clj/markdown/#orgmk","text":"( orgmk file ) ( defn ) ( defn orgmk [ file ] ( -> ( ProcessBuilder. [ \"org2gfm\" file ]) ( .start )))","title":"orgmk"},{"location":"org-roam-clj/markdown/#work","text":"( defmulti ) ( defmulti work ( fn [ k & _ ] k )) ( defmethod work :default [ _ ] identity ) ( defmethod work :pandoc [ _ file ] ( let [ filename ( .getPath file ) md-filename ( -> ( replace-extension filename \"md\" ) ( str/replace # \"^\\./\" \"\" )) p ( pandoc filename { :t :gfm :o ( ->> ( str \"docs-md/\" md-filename ))}) status ( .waitFor p )] ( println ( now-formatted ) \"Exit status for pandoc (\" filename \"): \" status )))","title":"work"},{"location":"org-roam-clj/markdown/#work-orgmk","text":"( work _ file ) ( defmethod ) ( defmethod work :orgmk [ _ file ] ( let [ filename ( .getPath file ) md-filename ( -> ( replace-extension filename \"md\" ) ( str/replace # \"^\\./\" \"\" )) dst ( io/file ( str \"docs-md/\" md-filename )) p ( orgmk filename ) status ( .waitFor p )] ( println ( now-formatted ) \"Exit status for orgmk (\" filename \"): \" status ) ( when ( zero? status ) ( when-not ( .exists dst ) ( io/make-parents dst )) ( io/copy ( io/file md-filename ) dst ) ( io/delete-file md-filename ))))","title":"work :orgmk"},{"location":"org-roam-clj/markdown/#work-mkdocs","text":"( work _ c ) ( defmethod ) ( defmethod work :mkdocs [ _ c ] ( a/put! c ( sh/sh \"mkdocs\" \"build\" )))","title":"work :mkdocs"},{"location":"org-roam-clj/markdown/#worker-pool","text":"( worker-pool n log-chan ) ( defn ) ( defn worker-pool [ n log-chan ] ( mapv ( fn [ _ ] ( worker-chan work log-chan )) ( range n )))","title":"worker-pool"},{"location":"org-roam-clj/markdown/#modified-files","text":"( modified-files fs ) ( defn ) ( defn modified-files [ fs ] ( let [ files-hashes ( ->> ( org-roam-clj.db/files-hashes ) ( reduce # ( assoc %1 ( :file %2 ) ( :hash %2 )) {}))] ( filter # ( not= ( get files-hashes ( str ( .getCanonicalPath % ))) ( sha1-str ( slurp ( str % )))) fs )))","title":"modified-files"},{"location":"org-roam-clj/markdown/#convert-org-files","text":"( convert-org-files ) ( convert-org-files root ) ( defn ) ( defn convert-org-files ([] ( convert-org-files \".\" )) ([ root ] ( let [ fs ( ->> ( file-seq ( io/file root )) ( filter # ( str/ends-with? % \".org\" )) modified-files ) size 16 master-chan ( chan size ) log-chan ( chan size ) log-mult ( a/mult log-chan ) println-chan ( chan size ) task-chan ( chan size ) terminated-tasks ( finished-tasks task-chan ) elapsed-time ( atom 0 )] ( a/tap log-mult println-chan ) ( a/tap log-mult task-chan ) ( log-tasks println-chan ) ( master-coordinator master-chan log-chan ( worker-pool size log-chan )) ( doseq [ org-file fs ] ( a/>!! master-chan [ :orgmk org-file ])) ( while ( and ( not= ( count @ terminated-tasks ) ( count fs )) ( not= @ elapsed-time 3600 )) ( when-not ( mod @ elapsed-time 5 ) ( a/offer! println-chan [ :log \"Waiting for conversion to finish\" ]) ( a/offer! println-chan [ :log \"Ratio: \" ( count @ terminated-tasks ) \"/\" ( count fs )])) ( a/<!! ( a/timeout 1000 )) ( swap! elapsed-time inc )) ( println ( count @ terminated-tasks ) ( count fs )) ( let [ final-chan ( chan )] ( a/>!! master-chan [ :mkdocs final-chan ]) ( println ( a/<!! final-chan ))) ( println \"Store files hashes for efficiency\" ) ( org-roam-clj.db/create-files-clj ) ( doseq [ f fs ] ( org-roam-clj.db/store-hash-content! f )))))","title":"convert-org-files"},{"location":"org-roam-clj/markdown/#clean-folder","text":"( clean-folder src ) ( defn ) ( defn clean-folder [ src ] ( let [ fs ( filter # ( str/ends-with? % \".md\" ) ( file-seq ( io/file src )))] ( doseq [ f fs ] ( io/delete-file f ))))","title":"clean-folder"},{"location":"org-roam-clj/markdown/#-main","text":"( -main ) ( defn ) ( defn -main [] ( println \"Starting to convert org-files\" ) ( convert-org-files ) ( println \"End of script\" ))","title":"-main"},{"location":"org-roam-clj/markdown/#rich-comment","text":"( comment ( tap> ( org-roam-clj.db/files-hashes )) )","title":"Rich Comment"},{"location":"org-roam-clj/tags/","text":"org-roam-clj.tags \u00b6 Automatically add links to org file with roam keys. Assumption: files and paths are absolute. The database is immutable for the life of the process. ( ns ) ( ns org-roam-clj.tags ( :require [ clojure.java.io :as io ] [ clojure.string :as str ] [ clojure.zip ] [ org-roam-clj.db ] [ org-roam-clj.utils :refer ( ->relative-path gather-org-files )] [ orgmode.core :as org ] [ orgmode.inline ])) root-location \u00b6 ( def ) ( def root-location ( System/getProperty \"user.dir\" )) header-content \u00b6 ( def ) ( def header-content \"See also (generated)\" ) ( def header-generate ( str \"** \" header-content )) get-headlines \u00b6 ( get-headlines z ) ( get-headlines z coll ) ( defn ) ( defn get-headlines ([ z ] ( get-headlines z # {})) ([ z coll ] ( if ( clojure.zip/end? z ) coll ( let [ node ( clojure.zip/node z ) coll ( case ( :type node ) :headline ( conj coll ( :text node )) coll )] ( recur ( clojure.zip/next z ) coll ))))) contains-genearted-links? \u00b6 ( contains-genearted-links? org-data ) ( defn ) ( defn contains-genearted-links? [ org-data ] ( let [ z ( clojure.zip/zipper ( some-fn map? vector? ) seq ( fn [ _ c ] c ) org-data )] ( contains? ( get-headlines z ) header-content ))) ->org-header \u00b6 ( ->org-header s level ) ( defn ) ( defn ->org-header [ s level ] ( str ( str/join ( repeat level \"*\" )) \" \" s )) enclose \u00b6 ( enclose text opener closer ) ( defn ) ( defn enclose [ text opener closer ] ( str opener text closer )) link \u00b6 ( link uri ) ( link uri alias ) ( defn ) ( defn link ([ uri ] ( link uri nil )) ([ uri alias ] ( -> ( str ( enclose uri \"[\" \"]\" ) ( when alias ( enclose alias \"[\" \"]\" ))) ( enclose \"[\" \"]\" )))) ->file-link \u00b6 ( ->file-link root filename alias ) ( defn ) ( defn ->file-link [ root filename alias ] ( link ( str \"file:\" ( ->relative-path root filename )) alias )) itemize \u00b6 ( itemize coll ) ( defn ) ( defn itemize [ coll ] ( ->> coll ( map # ( str \"- \" % )) ( str/join \"\\n\" ))) get-tags \u00b6 TODO: check if this works. ( get-tags x ) ( defn ) ( defn get-tags [ x ] ( when-let [ tags ( get-in x [ :attribs :roam-tags ])] ( str/split tags # \"\\s+\" ))) titles \u00b6 ( def ) ( def titles ( memoize org-roam-clj.db/titles )) ( def backlinks ( memoize org-roam-clj.db/backlinks )) ( def tags ( memoize org-roam-clj.db/tags )) filename->title \u00b6 ( def ) ( def filename->title ( memoize ( fn [] ( reduce # ( assoc %1 ( :file %2 ) ( first ( :titles %2 ))) {} ( titles ))))) tags->filename \u00b6 ( def ) ( def tags->filename ( let [ xf ( comp ( map # ( update % :titles ( fn [ s ] ( mapv str/lower-case s )))) ( map # ( zipmap ( :titles % ) ( repeat [( :file % )]))))] ( transduce xf ( fn ([ m ] m ) ([ x y ] ( merge-with into x y ))) {} ( titles )))) parse-org-link \u00b6 ( parse-org-link s ) ( defn ) ( defn parse-org-link [ s ] ( -> ( orgmode.inline/make-elem [ s ] orgmode.inline/link-re orgmode.inline/link-create ) first ( as-> $ ( assoc $ :alias ( -> $ :content first ))))) file->link \u00b6 ( file->link file tags->filename ) ( defn ) ( defn file->link [ file tags->filename ] ( let [ canonical-path ( fn [ file ] ( .getCanonicalPath file )) file ( canonical-path file ) query-tags ( fn [ tags ] ( for [ t ( sort tags ) :when t ] [ t ( get tags->filename t )])) org-links ( fn [ xs ] ( ->> ( for [[ t links ] xs :when ( and t links )] ( for [ link links :when ( not= link file )] ( ->file-link ( canonical-path ( . ( io/file file ) getParentFile )) ( canonical-path ( io/file link )) (( filename->title ) link )))) ( apply concat ) ( into # {}) ( sort-by # ( ->> % parse-org-link :alias str/lower-case ))))] ( ->> ( str file ) ( get ( tags )) query-tags org-links ))) file->backlink \u00b6 ( file->backlink file ) ( defn ) ( defn file->backlink [ file ] ( let [ canonical-path ( fn [ filename ] ( .getCanonicalPath ( io/file filename )))] ( ->> ( get ( backlinks ) ( str file )) ( map :from ) ( remove # { file }) ( map # ( vector % (( filename->title ) % ))) ( into # {}) ( sort-by # ( -> % second ( or ) str/lower-case )) ( mapv # ( ->file-link ( canonical-path ( . ( io/file file ) getParentFile )) ( canonical-path ( io/file ( first % ))) ( second % )))))) append-generated-links \u00b6 ( append-generated-links file links ) ( append-generated-links file links org-data ) ( defn ) ( defn append-generated-links ([ file links ] ( append-generated-links file links ( org/parse file ))) ([ file links org-data ] ( let [ org-links ( str \"\\n\" ( itemize links )) headline ( ->org-header header-content 2 )] ( if ( contains-genearted-links? org-data ) ( with-open [ reader ( io/reader ( str file ))] ( let [ line-reader ( line-seq reader ) [ content-before content-after ] ( -> # ( not ( str/starts-with? % headline )) ( split-with line-reader )) content-after ( ->> ( drop 1 content-after ) ( drop-while # ( not ( str/starts-with? % \"*\" ))))] ( -> ( concat content-before [ headline org-links ] [ \"\\n\" ] content-after ) vec ( as-> $ ( str/join \"\\n\" $ )) ( as-> $ ( assoc { :append false } :text $ :file file ))))) { :file file :append true :text ( str \"\\n\\n\" headline \"\\n\" org-links )})))) create-tag \u00b6 ( create-tag f ) ( defn ) ( defn create-tag [ f ] ( let [ file ( io/file f ) org-data ( org/parse file ) link ( ->> ( file->backlink ( .getCanonicalPath file )) ( into ( file->link file tags->filename )) ( into # {}) ( sort-by # ( -> % parse-org-link :alias str/lower-case ))) text-data ( if ( seq link ) ( append-generated-links file link org-data ) {})] text-data )) clear-generated-tags \u00b6 ( clear-generated-tags f ) ( defn ) ( defn clear-generated-tags [ f ] ( let [ file ( io/file f ) org-data ( org/parse file ) text-data ( append-generated-links file [] org-data )] text-data )) save-text! \u00b6 ( save-text! { :keys [ file text append ]}) ( defn ) ( defn save-text! [{ :keys [ file text append ]}] ( when file ( spit file text :append append ))) append-tags \u00b6 ( append-tags fs ) ( defn ) ( defn append-tags [ fs ] ( doseq [ f fs ] ( -> f create-tag save-text! ))) clear-tags \u00b6 ( clear-tags ) ( clear-tags root ) ( defn ) ( defn clear-tags ([] ( clear-tags \".\" )) ([ root ] ( let [ fs ( gather-org-files root )] ( doseq [ f fs ] ( -> f clear-generated-tags save-text! ))))) create-tags \u00b6 ( create-tags ) ( create-tags root ) ( defn ) ( defn create-tags ([] ( create-tags \".\" )) ([ root ] ( let [ fs ( gather-org-files root )] ( doseq [ f fs ] ( -> f create-tag save-text! ))))) Rich Comment \u00b6 ( comment ( append-tags ( gather-org-files )) ( clear-tags ( gather-org-files )) ( file->backlink \"/home/david/Documents/org_files/cards/python.org\" ) ( ->relative-path root-location \"/home/david/Documents/org_files/cards/clojure.org\" ) ( println ( :text ( create-tag \"/home/david/Documents/org_files/decks/clojure.org\" ))) { :type :headline :text \"See also (generated)\" :level 2 } ( link \"https://google.com\" ) ;; => \"[[https://google.com]]\" ( link \"https://google.com\" \"google\" ) ;; => \"[[https://google.com][google]]\" ( ->file-link root-location \"/home/david/Documents/org_files/cards/clojure.org\" \"clj\" ) ( itemize ( range 3 )) ;; => \"- 0\\n- 1\\n- 2\" ( -> ( get ( org/parse ( last fs )) :content ) last :content last ) ( contains-genearted-links? ( org/parse ( last fs ))) ( zipmap ( map str fs ) ( into [] ( comp ( map org/parse ) ( map get-tags )) fs )) ( org/parse ( nth fs 3 )) ;; do some errors parsing here ;; append generated-links ;; (take-while #(not (str/starts-with \"** See also (generated)\" %)) line-seq) ;; overwrite generated-links (spit :append) ( let [ file ( io/file \"./todo.org\" ) org-data ( org/parse file ) link ( file->link file tags->filename )] ( tap> ( vec link )) # _ ( when ( seq link ) ( def x ( append-generated-links file link org-data )))) ( org/parse ( nth fs 10 )) ( def org-data ( org/parse ( io/file \"./index.org\" ))) ( def z ( clojure.zip/zipper ( some-fn map? vector? ) seq ( fn [ _ c ] c ) org-data )) ( get-headlines z []) ( = ( select-keys ( parse-org-link \"[[a][abcd]]\" ) [ :alias :uri ]) { :uri \"a\" , :alias \"abcd\" }) ( re-seq # \"\\[[^]]+]\" \"[[file:cards/clojure.org][Clojure]]\" ) ( conj # { 1 2 } 3 ) ;; TODO(dph) add the back links using the links table ;; (clojure.core/require '[shadow.cljs.devtools.server :as server]) ;; (server/start!))","title":"org-roam-clj.tags"},{"location":"org-roam-clj/tags/#org-roam-cljtags","text":"Automatically add links to org file with roam keys. Assumption: files and paths are absolute. The database is immutable for the life of the process. ( ns ) ( ns org-roam-clj.tags ( :require [ clojure.java.io :as io ] [ clojure.string :as str ] [ clojure.zip ] [ org-roam-clj.db ] [ org-roam-clj.utils :refer ( ->relative-path gather-org-files )] [ orgmode.core :as org ] [ orgmode.inline ]))","title":"org-roam-clj.tags"},{"location":"org-roam-clj/tags/#root-location","text":"( def ) ( def root-location ( System/getProperty \"user.dir\" ))","title":"root-location"},{"location":"org-roam-clj/tags/#header-content","text":"( def ) ( def header-content \"See also (generated)\" ) ( def header-generate ( str \"** \" header-content ))","title":"header-content"},{"location":"org-roam-clj/tags/#get-headlines","text":"( get-headlines z ) ( get-headlines z coll ) ( defn ) ( defn get-headlines ([ z ] ( get-headlines z # {})) ([ z coll ] ( if ( clojure.zip/end? z ) coll ( let [ node ( clojure.zip/node z ) coll ( case ( :type node ) :headline ( conj coll ( :text node )) coll )] ( recur ( clojure.zip/next z ) coll )))))","title":"get-headlines"},{"location":"org-roam-clj/tags/#contains-genearted-links","text":"( contains-genearted-links? org-data ) ( defn ) ( defn contains-genearted-links? [ org-data ] ( let [ z ( clojure.zip/zipper ( some-fn map? vector? ) seq ( fn [ _ c ] c ) org-data )] ( contains? ( get-headlines z ) header-content )))","title":"contains-genearted-links?"},{"location":"org-roam-clj/tags/#-org-header","text":"( ->org-header s level ) ( defn ) ( defn ->org-header [ s level ] ( str ( str/join ( repeat level \"*\" )) \" \" s ))","title":"-&gt;org-header"},{"location":"org-roam-clj/tags/#enclose","text":"( enclose text opener closer ) ( defn ) ( defn enclose [ text opener closer ] ( str opener text closer ))","title":"enclose"},{"location":"org-roam-clj/tags/#link","text":"( link uri ) ( link uri alias ) ( defn ) ( defn link ([ uri ] ( link uri nil )) ([ uri alias ] ( -> ( str ( enclose uri \"[\" \"]\" ) ( when alias ( enclose alias \"[\" \"]\" ))) ( enclose \"[\" \"]\" ))))","title":"link"},{"location":"org-roam-clj/tags/#-file-link","text":"( ->file-link root filename alias ) ( defn ) ( defn ->file-link [ root filename alias ] ( link ( str \"file:\" ( ->relative-path root filename )) alias ))","title":"-&gt;file-link"},{"location":"org-roam-clj/tags/#itemize","text":"( itemize coll ) ( defn ) ( defn itemize [ coll ] ( ->> coll ( map # ( str \"- \" % )) ( str/join \"\\n\" )))","title":"itemize"},{"location":"org-roam-clj/tags/#get-tags","text":"TODO: check if this works. ( get-tags x ) ( defn ) ( defn get-tags [ x ] ( when-let [ tags ( get-in x [ :attribs :roam-tags ])] ( str/split tags # \"\\s+\" )))","title":"get-tags"},{"location":"org-roam-clj/tags/#titles","text":"( def ) ( def titles ( memoize org-roam-clj.db/titles )) ( def backlinks ( memoize org-roam-clj.db/backlinks )) ( def tags ( memoize org-roam-clj.db/tags ))","title":"titles"},{"location":"org-roam-clj/tags/#filename-title","text":"( def ) ( def filename->title ( memoize ( fn [] ( reduce # ( assoc %1 ( :file %2 ) ( first ( :titles %2 ))) {} ( titles )))))","title":"filename-&gt;title"},{"location":"org-roam-clj/tags/#tags-filename","text":"( def ) ( def tags->filename ( let [ xf ( comp ( map # ( update % :titles ( fn [ s ] ( mapv str/lower-case s )))) ( map # ( zipmap ( :titles % ) ( repeat [( :file % )]))))] ( transduce xf ( fn ([ m ] m ) ([ x y ] ( merge-with into x y ))) {} ( titles ))))","title":"tags-&gt;filename"},{"location":"org-roam-clj/tags/#parse-org-link","text":"( parse-org-link s ) ( defn ) ( defn parse-org-link [ s ] ( -> ( orgmode.inline/make-elem [ s ] orgmode.inline/link-re orgmode.inline/link-create ) first ( as-> $ ( assoc $ :alias ( -> $ :content first )))))","title":"parse-org-link"},{"location":"org-roam-clj/tags/#file-link","text":"( file->link file tags->filename ) ( defn ) ( defn file->link [ file tags->filename ] ( let [ canonical-path ( fn [ file ] ( .getCanonicalPath file )) file ( canonical-path file ) query-tags ( fn [ tags ] ( for [ t ( sort tags ) :when t ] [ t ( get tags->filename t )])) org-links ( fn [ xs ] ( ->> ( for [[ t links ] xs :when ( and t links )] ( for [ link links :when ( not= link file )] ( ->file-link ( canonical-path ( . ( io/file file ) getParentFile )) ( canonical-path ( io/file link )) (( filename->title ) link )))) ( apply concat ) ( into # {}) ( sort-by # ( ->> % parse-org-link :alias str/lower-case ))))] ( ->> ( str file ) ( get ( tags )) query-tags org-links )))","title":"file-&gt;link"},{"location":"org-roam-clj/tags/#file-backlink","text":"( file->backlink file ) ( defn ) ( defn file->backlink [ file ] ( let [ canonical-path ( fn [ filename ] ( .getCanonicalPath ( io/file filename )))] ( ->> ( get ( backlinks ) ( str file )) ( map :from ) ( remove # { file }) ( map # ( vector % (( filename->title ) % ))) ( into # {}) ( sort-by # ( -> % second ( or ) str/lower-case )) ( mapv # ( ->file-link ( canonical-path ( . ( io/file file ) getParentFile )) ( canonical-path ( io/file ( first % ))) ( second % ))))))","title":"file-&gt;backlink"},{"location":"org-roam-clj/tags/#append-generated-links","text":"( append-generated-links file links ) ( append-generated-links file links org-data ) ( defn ) ( defn append-generated-links ([ file links ] ( append-generated-links file links ( org/parse file ))) ([ file links org-data ] ( let [ org-links ( str \"\\n\" ( itemize links )) headline ( ->org-header header-content 2 )] ( if ( contains-genearted-links? org-data ) ( with-open [ reader ( io/reader ( str file ))] ( let [ line-reader ( line-seq reader ) [ content-before content-after ] ( -> # ( not ( str/starts-with? % headline )) ( split-with line-reader )) content-after ( ->> ( drop 1 content-after ) ( drop-while # ( not ( str/starts-with? % \"*\" ))))] ( -> ( concat content-before [ headline org-links ] [ \"\\n\" ] content-after ) vec ( as-> $ ( str/join \"\\n\" $ )) ( as-> $ ( assoc { :append false } :text $ :file file ))))) { :file file :append true :text ( str \"\\n\\n\" headline \"\\n\" org-links )}))))","title":"append-generated-links"},{"location":"org-roam-clj/tags/#create-tag","text":"( create-tag f ) ( defn ) ( defn create-tag [ f ] ( let [ file ( io/file f ) org-data ( org/parse file ) link ( ->> ( file->backlink ( .getCanonicalPath file )) ( into ( file->link file tags->filename )) ( into # {}) ( sort-by # ( -> % parse-org-link :alias str/lower-case ))) text-data ( if ( seq link ) ( append-generated-links file link org-data ) {})] text-data ))","title":"create-tag"},{"location":"org-roam-clj/tags/#clear-generated-tags","text":"( clear-generated-tags f ) ( defn ) ( defn clear-generated-tags [ f ] ( let [ file ( io/file f ) org-data ( org/parse file ) text-data ( append-generated-links file [] org-data )] text-data ))","title":"clear-generated-tags"},{"location":"org-roam-clj/tags/#save-text","text":"( save-text! { :keys [ file text append ]}) ( defn ) ( defn save-text! [{ :keys [ file text append ]}] ( when file ( spit file text :append append )))","title":"save-text!"},{"location":"org-roam-clj/tags/#append-tags","text":"( append-tags fs ) ( defn ) ( defn append-tags [ fs ] ( doseq [ f fs ] ( -> f create-tag save-text! )))","title":"append-tags"},{"location":"org-roam-clj/tags/#clear-tags","text":"( clear-tags ) ( clear-tags root ) ( defn ) ( defn clear-tags ([] ( clear-tags \".\" )) ([ root ] ( let [ fs ( gather-org-files root )] ( doseq [ f fs ] ( -> f clear-generated-tags save-text! )))))","title":"clear-tags"},{"location":"org-roam-clj/tags/#create-tags","text":"( create-tags ) ( create-tags root ) ( defn ) ( defn create-tags ([] ( create-tags \".\" )) ([ root ] ( let [ fs ( gather-org-files root )] ( doseq [ f fs ] ( -> f create-tag save-text! )))))","title":"create-tags"},{"location":"org-roam-clj/tags/#rich-comment","text":"( comment ( append-tags ( gather-org-files )) ( clear-tags ( gather-org-files )) ( file->backlink \"/home/david/Documents/org_files/cards/python.org\" ) ( ->relative-path root-location \"/home/david/Documents/org_files/cards/clojure.org\" ) ( println ( :text ( create-tag \"/home/david/Documents/org_files/decks/clojure.org\" ))) { :type :headline :text \"See also (generated)\" :level 2 } ( link \"https://google.com\" ) ;; => \"[[https://google.com]]\" ( link \"https://google.com\" \"google\" ) ;; => \"[[https://google.com][google]]\" ( ->file-link root-location \"/home/david/Documents/org_files/cards/clojure.org\" \"clj\" ) ( itemize ( range 3 )) ;; => \"- 0\\n- 1\\n- 2\" ( -> ( get ( org/parse ( last fs )) :content ) last :content last ) ( contains-genearted-links? ( org/parse ( last fs ))) ( zipmap ( map str fs ) ( into [] ( comp ( map org/parse ) ( map get-tags )) fs )) ( org/parse ( nth fs 3 )) ;; do some errors parsing here ;; append generated-links ;; (take-while #(not (str/starts-with \"** See also (generated)\" %)) line-seq) ;; overwrite generated-links (spit :append) ( let [ file ( io/file \"./todo.org\" ) org-data ( org/parse file ) link ( file->link file tags->filename )] ( tap> ( vec link )) # _ ( when ( seq link ) ( def x ( append-generated-links file link org-data )))) ( org/parse ( nth fs 10 )) ( def org-data ( org/parse ( io/file \"./index.org\" ))) ( def z ( clojure.zip/zipper ( some-fn map? vector? ) seq ( fn [ _ c ] c ) org-data )) ( get-headlines z []) ( = ( select-keys ( parse-org-link \"[[a][abcd]]\" ) [ :alias :uri ]) { :uri \"a\" , :alias \"abcd\" }) ( re-seq # \"\\[[^]]+]\" \"[[file:cards/clojure.org][Clojure]]\" ) ( conj # { 1 2 } 3 ) ;; TODO(dph) add the back links using the links table ;; (clojure.core/require '[shadow.cljs.devtools.server :as server]) ;; (server/start!))","title":"Rich Comment"},{"location":"org-roam-clj/utils/","text":"org-roam-clj.utils \u00b6 ( ns ) ( ns org-roam-clj.utils ( :require [ clojure.java.io :as io ] [ clojure.string :as str ]) ( :import [ java.net URI ] [ java.nio.file Paths ] [ java.security MessageDigest ])) debug \u00b6 ( debug x ) ( defn ) ( defn debug [ x ] ( println x ) x ) now \u00b6 ( now ) ( defn ) ( defn now [] ( java.time.ZonedDateTime/now )) ( defn now-formatted [] ( .format ( now ) ( java.time.format.DateTimeFormatter/ofPattern \"YYYYMMdd hhmmss.SSS: \" ))) extension \u00b6 ( extension path ) ( defn ) ( defn extension [ path ] ( subs path ( str/last-index-of path \".\" ))) replace-extension \u00b6 ( replace-extension path extension ) ( defn ) ( defn replace-extension [ path extension ] ( -> path ( subs 0 ( str/last-index-of path \".\" )) ( str \".\" extension ))) replace-root \u00b6 ( replace-root path root ) ( defn ) ( defn replace-root [ path root ] ( str root \"/\" ( str/replace path # \"^[^/]*/\" ))) ->Path \u00b6 ( ->Path s ) ( defn ) ( defn ->Path [ s ] ( ->> ( str/replace s # \"^\\.\" ) ( str \"file://\" ) ( URI. ) Paths/get ( .normalize ))) ->relative-path \u00b6 Returns the relative path of location with respect to root ( ->relative-path root location ) ( defn ) ( defn ->relative-path [ root location ] ( -> ( .relativize ( ->Path root ) ( ->Path location )) ( .normalize ) str )) gather-org-files \u00b6 ( gather-org-files ) ( gather-org-files root ) ( defn ) ( defn gather-org-files ([] ( gather-org-files \".\" )) ([ root ] ( into [] ( comp ( filter # ( str/ends-with? % \".org\" )) ( map # ( .getCanonicalPath % ))) ( file-seq ( io/file root ))))) sha1-str \u00b6 ( sha1-str s ) ( defn ) ( defn sha1-str [ s ] ( let [ digested ( -> \"sha1\" MessageDigest/getInstance ( .digest ( .getBytes s )))] ( ->> digested ( map # ( .substring ( Integer/toString ( + ( bit-and % 0 xff ) 0 x100 ) 16 ) 1 )) ( apply str )))) gather-org-files \u00b6 ( gather-org-files root ) ( defn ) ( defn gather-org-files [ root ] ( filterv # ( str/ends-with? % \".org\" ) ( file-seq ( io/file root ))))","title":"org-roam-clj.utils"},{"location":"org-roam-clj/utils/#org-roam-cljutils","text":"( ns ) ( ns org-roam-clj.utils ( :require [ clojure.java.io :as io ] [ clojure.string :as str ]) ( :import [ java.net URI ] [ java.nio.file Paths ] [ java.security MessageDigest ]))","title":"org-roam-clj.utils"},{"location":"org-roam-clj/utils/#debug","text":"( debug x ) ( defn ) ( defn debug [ x ] ( println x ) x )","title":"debug"},{"location":"org-roam-clj/utils/#now","text":"( now ) ( defn ) ( defn now [] ( java.time.ZonedDateTime/now )) ( defn now-formatted [] ( .format ( now ) ( java.time.format.DateTimeFormatter/ofPattern \"YYYYMMdd hhmmss.SSS: \" )))","title":"now"},{"location":"org-roam-clj/utils/#extension","text":"( extension path ) ( defn ) ( defn extension [ path ] ( subs path ( str/last-index-of path \".\" )))","title":"extension"},{"location":"org-roam-clj/utils/#replace-extension","text":"( replace-extension path extension ) ( defn ) ( defn replace-extension [ path extension ] ( -> path ( subs 0 ( str/last-index-of path \".\" )) ( str \".\" extension )))","title":"replace-extension"},{"location":"org-roam-clj/utils/#replace-root","text":"( replace-root path root ) ( defn ) ( defn replace-root [ path root ] ( str root \"/\" ( str/replace path # \"^[^/]*/\" )))","title":"replace-root"},{"location":"org-roam-clj/utils/#-path","text":"( ->Path s ) ( defn ) ( defn ->Path [ s ] ( ->> ( str/replace s # \"^\\.\" ) ( str \"file://\" ) ( URI. ) Paths/get ( .normalize )))","title":"-&gt;Path"},{"location":"org-roam-clj/utils/#-relative-path","text":"Returns the relative path of location with respect to root ( ->relative-path root location ) ( defn ) ( defn ->relative-path [ root location ] ( -> ( .relativize ( ->Path root ) ( ->Path location )) ( .normalize ) str ))","title":"-&gt;relative-path"},{"location":"org-roam-clj/utils/#gather-org-files","text":"( gather-org-files ) ( gather-org-files root ) ( defn ) ( defn gather-org-files ([] ( gather-org-files \".\" )) ([ root ] ( into [] ( comp ( filter # ( str/ends-with? % \".org\" )) ( map # ( .getCanonicalPath % ))) ( file-seq ( io/file root )))))","title":"gather-org-files"},{"location":"org-roam-clj/utils/#sha1-str","text":"( sha1-str s ) ( defn ) ( defn sha1-str [ s ] ( let [ digested ( -> \"sha1\" MessageDigest/getInstance ( .digest ( .getBytes s )))] ( ->> digested ( map # ( .substring ( Integer/toString ( + ( bit-and % 0 xff ) 0 x100 ) 16 ) 1 )) ( apply str ))))","title":"sha1-str"},{"location":"org-roam-clj/utils/#gather-org-files_1","text":"( gather-org-files root ) ( defn ) ( defn gather-org-files [ root ] ( filterv # ( str/ends-with? % \".org\" ) ( file-seq ( io/file root ))))","title":"gather-org-files"}]}